<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>工具箱里都有啥？ on 狗蛋日</title><link>http://young-mann.top/tags/%E5%B7%A5%E5%85%B7%E7%AE%B1%E9%87%8C%E9%83%BD%E6%9C%89%E5%95%A5/</link><description>Recent content in 工具箱里都有啥？ on 狗蛋日</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 16 May 2023 14:31:37 +0800</lastBuildDate><atom:link href="http://young-mann.top/tags/%E5%B7%A5%E5%85%B7%E7%AE%B1%E9%87%8C%E9%83%BD%E6%9C%89%E5%95%A5/index.xml" rel="self" type="application/rss+xml"/><item><title>事件域在金融随机分析中的含义</title><link>http://young-mann.top/posts/sigma%E4%BB%A3%E6%95%B0%E7%9A%84%E7%9B%B4%E8%A7%82%E5%90%AB%E4%B9%89/</link><pubDate>Tue, 16 May 2023 14:31:37 +0800</pubDate><guid>http://young-mann.top/posts/sigma%E4%BB%A3%E6%95%B0%E7%9A%84%E7%9B%B4%E8%A7%82%E5%90%AB%E4%B9%89/</guid><description>事件域——划分的精细程度代表所知信息的多寡 简单来说，sigma 代数刻画的事件域 $\mathcal F$ 包含了一系列划分后的集合，后文称作「分类」，which 可以被我们用来对样本空间 $\Omega$ 中的样本路径 $\omega$ 进行归类。这些分类，实际上表示我们对于当前样本路径的了解程度：我们在某一阶段 $T$ 所知道的信息越多，这一阶段的事件域 $\mathcal F _T$ 所包含的元素就越多，表示我们 $\omega$ 所能采用的分类也就越多。
这些分类是怎样描述「所知道的信息」的？一种可行的思路是思路是，对于某个随机过程，我们会面临一条事前确定的样本路径 $\omega_i$ 。然而，尽管这条样本路径是已经被「固定」的，但我们并不知道 $\omega_i$ 是 $\Omega$ 中的哪一个 $\omega$ ——我们仅能知道，对于给定的 $\Omega$ 的某个子集，$\omega_i$ 是不是在这个子集里面。而前一句中 能够被判断是否包含 $\omega_i$ 的这些 $\Omega$ 的子集，就是我们在第一段中提到的，事件域 $\mathcal F$ 所包含的「分类」。如果对集合的划分越精细，「分类」就越多，表示我们知道的信息就更多。
一个例子 对于分类如何刻画信息，现在就来举个直观的例子。假设我现在要扔一枚质地均匀的硬币，扔个 2 次。将硬币的某一面记作正面，与其相反的一面记作反面。将「硬币投出了正面」记作 H （假设其可能性为 $p,p&amp;gt;0$ ），将「硬币投出了反面」记作 T （假设其可能性为 0&amp;quot;&amp;gt;$q, q=1-p&amp;gt;0$ ）。以一串序列 $\omega$ （其中 $\omega=\omega_1\omega_2$ ， 的可能取值为或$\omega_i的可能取值为H或T$ ）列出所有可能发生的结果，便可得样本空间 $\Omega = \lbrace \text{HH, HT, TH, TT}\rbrace.$
再定义一个随机变量 $S$ ，用于表示股票价格：
$$ \begin{align} S_0(\omega) &amp;amp;= 4, \forall \omega \in \Omega \\ S_1(\omega) &amp;amp;= \begin{cases} 8, &amp;amp; 如果 \omega_1=H \ 2, &amp;amp; 如果 \omega_1=T \ \end{cases} \\ S_2(\omega) &amp;amp;= \begin{cases} 16, &amp;amp; 如果 \omega_1=\omega_2=H \ 4, &amp;amp; 如果 \omega_1\neq \omega_2 \ 1, &amp;amp; 如果 \omega_1=\omega_2=T \end{cases} \end{align} $$</description></item><item><title>侃侃「贷款创造理论」</title><link>http://young-mann.top/posts/%E8%B4%B7%E6%AC%BE%E5%88%9B%E9%80%A0%E7%90%86%E8%AE%BA/</link><pubDate>Fri, 21 Oct 2022 17:02:58 +0800</pubDate><guid>http://young-mann.top/posts/%E8%B4%B7%E6%AC%BE%E5%88%9B%E9%80%A0%E7%90%86%E8%AE%BA/</guid><description>在《货币创造的逻辑形成和历史演进——对传统货币理论的批判》一文里，孙国峰总结了「贷款创造存款」理论（loan creates deposit, LCD）的逻辑以及发展。
LCD 的内涵1包括：第一，货币创造是「银行放贷行为」本身，而不是传统教科书中所说的「先有存款进银行，银行再拿这笔钱放贷，就这样存了贷、贷了继续存」。第二，银行放贷是银行与客户的债权债务交换行为，其中，银行获得贷款债权，客户获得存款债权。第三，客户需付出额外的利差才可获取存款债权。客户之所以愿意接受利差，是因为其从银行获得的存款债权也被其他人认可，转移起来比较方便。这样的存款债权，就可成为信用货币。这种信用货币，并不是一种作为基础物质存在的实物「货币金额」，而是债权债务关系的的反映，是在记录这种债权债务关系、存款贷款同时出现的过程中「无中生有」的。相比之下，货币银行理论认为，在每一笔存款与每一笔贷款之间，都是有实实在在的「货币金额」为内容的经济行为，并没有任何「凭空创造」的意思。第四，为了支持贷款创造货币的行为，银行需要持有基础货币。
下面来举一个简单的例子，从资产负债表的角度说明 LCD 与传统货币银行理论在货币创造上的解释有所不同。
假设法定存款准备金率为 20 %，客户将现金存入银行后不会提现。第一家银行（记作 A）首先吸收了 100 元的「原始存款」，其中 20 元用于「缴存存款准备金」，剩下的 80 元放贷。客户得到了 80 元贷款后，用于支付给另一个客户，而这个新客户会将 80 元存入另一家银行（记作 B）。银行 B 再缴存 16元存款准备金后，再放贷 64 元。经历了这 2 个步骤后，银行 A 与银行 B 的资产负债表如下图所示。经历如此这般「存款-贷款-再存款-再放贷」的一轮轮接力后，最初存入银行的 100 元的「原始存款」全部变成准备金，再也无法拿出去放贷。此时，计算银行总体的资产负债表，会发现负债端有 500 元存款，资产端有 400 元贷款和 100 元准备金。
然而，在 LCD 这里，第 2 布的资产负债表就不太一样了。不同之处在于，在银行 A 放出一笔 80 元的新贷款的时候，就已经创造出了新的 80 元存款货币（也就是资产端 下方新出现的 80 元现金），并在此时向中央银行存入 16 元作为存款准备金。如果客户在贷款后继续购买商品，那么银行 A 与银行 B 的资产负债表还会发生变化，但这个变化的过程已经和传统货币银行理论中所描述的不一样了。
若想了解更多孙国峰对 LCD 的阐释，可见孙国峰（2019）。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>蒙特卡罗估计简介</title><link>http://young-mann.top/posts/mc/</link><pubDate>Thu, 20 Oct 2022 21:50:02 +0800</pubDate><guid>http://young-mann.top/posts/mc/</guid><description>本文是对《金融工程中的蒙特卡罗方法》一书的读书笔记。
蒙特卡洛原理 蒙特卡洛方法是什么？ 蒙特卡罗方法是一种用于模拟随机现象，以求得事件的概率的统计模拟方法。借助测度论的语言，我们可对概率论做一种公理化定义1，将随机试验中随机发生的事件与一个集合对应起来（这个集合包含了事件发生时的所有可能结果），将总体也与一个集合对应起来（这个集合包含了随机试验的所有可能结果），从而将概率定义为：
$$某事件的概率 := \frac{该事件对应集合的容量}{总体对应集合的容量}$$
确定了这个定义之后，我们便可以通过计算事件对应集合的容量与总体对应集合的容值，计算某个事件的概率——而实际上蒙特卡罗方法就是这么做的。比如，我们现在想要计算某个事件发生的概率。那么，我们可以做的是，在所有可能结果组成的总体中随机抽样，然后计算落入事件对应集合的样本点所占总体的比例，以此比例「估计」事件对应集合的容量。在这一过程中，大数定律保证了这个估计会随着抽样的增加而收敛于真实值2，中心极限定理则给出了在有限次抽样下估计误差的可能幅度。
为了更方便地计算集合的度量，我们可以引入积分这个工具。考虑一个简单的例子：假设我们现在需要估计一个给定函数$f$在单位区间上的积分值。为书写方便起见，我们可以将这个积分值记作 $\alpha$，则有： $$ \alpha = \int^1_0f(x) \mathop{}!\mathrm{d}x. $$ $\alpha$ 可以被看作期望值 $\mathbb{E}[f(U)]$，其中 $U \sim\text{Uniform}(0,1)$。假设我们可以在 $[0,1]$ 上独立均匀地抽样得到 $U_1,U_2,\cdots$，那么计算 $f$ 在这些样本点上的取值并求平均，便可得到欲求积分值的一个蒙特卡洛估计： $$ \hat \alpha n = \frac1n \sum^n{i=1}f(U_i). $$ 如果函数 $f$ 满足一些特定性质，我们就能得到一个误差较低的 $\alpha$ 估计值，并且可以显式地求出这个估计的误差值。
先来看看 $\alpha$ 的具体估计取值。如果函数 $f$ 在 $[0,1]$ 上可积，那么根据强大数定律，有： $$ 当\ n \to \infty \ 时,\ \hat \alpha_n \stackrel{a.s.} \longrightarrow \alpha. $$ 再来看看估计的误差值。如果函数 $f$ 平方可积，那么蒙特卡洛估计中的误差项 $\hat \alpha_n - \alpha$ 近似服从于 $\text{Normal}(0, {\sigma_f^2}/{ n})$，而且 $n$ 越大，这个误差项就越近似于上述的正态分布。需要补充的是，这个正态分布中的总体方差 $\sigma_f$ 定义如下： $$ \sigma_f^2 = \int^1_0 (f(x)-\alpha)^2 \mathop{}!</description></item><item><title>C++ design patterns and derivatives pricing</title><link>http://young-mann.top/posts/design-patterns-and-derivatives-pricing/</link><pubDate>Tue, 09 Aug 2022 00:42:05 +0800</pubDate><guid>http://young-mann.top/posts/design-patterns-and-derivatives-pricing/</guid><description>Book Link: C++ Design Patterns and Derivatives Pricing
本文用于记录读完 C++ design patterns and derivatives pricing 后的代码实践。
ch1-VanillaCallOption 在第 1 章的文件夹里，主要实现了 1 个简单的看涨期权（call option）的定价模型，由 3 部分组成。主程序是 SimpleMCMain1.cpp ，其中需要用到生成随机数的功能，所以引入了 1 个头文件（只有函数声明）的 Random1.h ，以及具体实现该功能的头文件 Random1_Implementation.h 1。
ch2-Encapsulation 在第 2 章，对于常用的功能进行了封装。这章用到的文件具体如下（表格内省略了用于实现接口的文件，例如 “Random1_Implementation.h”，后文的表格皆是如此）：
文件名称 用途 Random1.h 生成随机数的函数 PayOff1.h 以 Strike 与 TheOptionsType 为私有变量的 PayOff 类，主要特点由：1. 以 enum OptionType {call, put} 区分不同类型期权的定价方式（这里是 2 种：看涨期权、看跌期权）；2. 通过double operator() (double Spot) const 重载运算符 () ，以计算给定期权的 PayOff SimpleMC.h 用于最终定价的 Monte-Carlo 函数 SimpleMCMain2.</description></item><item><title>浮点数的取值范围</title><link>http://young-mann.top/posts/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</link><pubDate>Tue, 23 Feb 2021 22:58:40 +0800</pubDate><guid>http://young-mann.top/posts/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</guid><description>本文以单精度浮点格式（即C++中的float类型）为例，简要介绍 IEEE754 标准中浮点数的表示方法，以及该表示方法中需要特别注意的部分（即浮点数中的阶码是以移码形式存储的），并基于上述两点，求得单精度浮点数的有效数字的位数以及取值范围。其他类型浮点格式的有效数字位数及取值范围可依此类推。
前置知识 若想了解浮点数在计算机内被如何存储，就必须先了解 IEEE754 标准，which 制定了计算机内浮点数及其运算的标准，被目前几乎所有的计算机所支持。
IEEE754 标准 根据IEEE浮点数标准，一个浮点数可表达为： $$ V=(-1)^s \times M \times 2^E $$
其中，
V 表示所表示的浮点数的实际值 s 为符号位(Sign)，表示该浮点数为正数或负数。若为正数，则 s 取值为0；若为负数，则 s 取值为1 (注：对于数值0的符号位需要特殊处理) M 为尾数(Mantissa)，是一个二进制小数，用于确定浮点数的精度，以定点数的形式存储在计算机内部（注意：此处的尾数的形式实为1.ffffff，而非0.fffffff，这个特征在下文讨论移码时会被重新提及） E 为阶码(Exponent)，用于对浮点数进行加权 (!!!注意!!!：阶码的取值可正可负，是一个有符号数，分别代表小数点是向左移还是向右移。出于使用上的便利，在存储阶码时用到了特别的方式，即下文即将提到的移码(Excess-N System) ） 将浮点数的位表示划分为三个字段，并分别对这些值进行编码，便可表示出浮点数的实际值。以单精度浮点格式为例。在单精度浮点格式中，符号位s、阶码E和尾数M的尾数分别为1位、8位和23位，将三者联立便可得到以32位表示出的浮点数，具体形式可参见下图：
图源：Foundations of Computer Science (2018), Behrouz Forouzan
阶码的存储形式——移码 (Excess-N System) 为啥不能用补码存储阶码？ 在上文中我们提到，阶码 E 是一个有符号数，用于表示小数点需要向左或向右移动的位数。那么，在存储阶码时，根据此前所学的知识，我们自然会想到以补码 (2&amp;rsquo;s complement) 的形式存储阶码。
但是，我们在课本上看到的阶码可不是用补码表示的。这是为什么呢？说实话，我不太确定真正的原因，现在能想到的理由如下：以补码表示的阶码会出现一个新的符号位（区别于上文 IEEE754 标准中所提到的符号位s），使得一个浮点数中出现两个符号位：浮点数本身的，以及浮点数阶码前的。这时，如果要对浮点数进行运算或者比较，无法采用整数那样的简单的二进制比较，所以算起来并不方便。
那有啥更好的方法存储阶码？ 既然不能用补码，那我们只能另辟蹊径了。回顾用补码表示阶码所产生的问题，可以发现，阶码作为有符号数时具备的符号位是引发麻烦的源头，那么为了方便起见，只能想着除去符号位了。基于这种思想，前人提出了移码(Excess-N System)的存储方式。简单而言，补码在存储阶码时所起到的作用，便是对于 作为有符号数的阶码 的所有可能取值，分别增加一个特定的值N（即$2^{m_E-1}-1$，也是上文中Excess-N中N的含义），从而将原本所有可能的取值映射到一个新的正数集合。基于该正数集合，我们可以找出与原阶码一一对应的无符号数。通过移码，我们不再需要考虑如何处理原本作为有符号数的阶码所包含的符号位（因为阶码的所有可能取值已经被我们映射到了一个正整数集合）。因此，当我们需要对阶码进行运算或比较时，便可以将这些运算或比较先作用于新的整数集合上，再通过映射的逆操作得到我们所需的阶码值。
等等……上面那个用于增加的值 $2^{m_E-1}-1$ 是啥玩意儿？ 至此，移码在阶码存储中的用途便讲得差不多了……不过，我是不是忘了什么？哦，在读上面那段的时候，你可能在想，那个$2^{m_E-1}-1$是啥？简单来说，这是将有符号数的阶码全部映射成正整数的一个比较合适的取值，其中$m_E$ 表示的是存储阶码可用的存储单元的位数，在单精度浮点格式里是8位。
还是以单精度浮点格式为例。上文中，我们提到，作为有符号数的阶码有正有负，在单精度浮点格式里的取值范围是 -126~127 （为啥不是 -128~127 ?</description></item></channel></rss>