<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>工具::数学 on 斐康明</title><link>https://young-mann.top/categories/%E5%B7%A5%E5%85%B7%E6%95%B0%E5%AD%A6/</link><description>Recent content in 工具::数学 on 斐康明</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 18 May 2021 19:31:10 +0800</lastBuildDate><atom:link href="https://young-mann.top/categories/%E5%B7%A5%E5%85%B7%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>关系数据理论</title><link>https://young-mann.top/posts/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</link><pubDate>Tue, 18 May 2021 19:31:10 +0800</pubDate><guid>https://young-mann.top/posts/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</guid><description>&lt;p>本文是《数据库系统概论》的第6章以及“Database System: The Complete Book”的第三章所作的部分笔记，用以理解数据库设计过程中的关系数据理论。笔者认为，在这些教材中，对于关系数据理论的阐释可被归结为对于以下几个问题的回应：&lt;/p>
&lt;ul>
&lt;li>一个糟糕的数据库设计是什么样的，又会为使用者带来多少麻烦？&lt;strong>（问题的引入）&lt;/strong>&lt;/li>
&lt;li>是否存在某些可以遵循的准则，帮助我们设计出“不那么糟糕”的数据库？&lt;strong>（规范化理论）&lt;/strong>&lt;/li>
&lt;li>在了解“不那么糟糕的数据库应该是什么样的”之后，我们又能采取哪些措施，让我们在设计数据库时满足这些让数据库运作得更好的条件？&lt;strong>（Armstrong公理&amp;amp;模式分解）&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="预备知识">预备知识&lt;/h2>
&lt;p>为了更好地理解下文的内容，读者首先需要掌握关系数据理论中的部分基本概念：&lt;/p>
&lt;h3 id="函数依赖functional-dependency">函数依赖(Functional Dependency)&lt;/h3>
&lt;ul>
&lt;li>函数依赖：设 R(U) 是属性集U的关系模型, X, Y是U的一个子集, 对于 R(U) 中的任一个关系 r, 不可能存在两个元组在 X 上属性值相同, 而在 Y 上属性值不同。则称 &lt;strong>X 函数确定 Y&lt;/strong> , 或 &lt;strong>Y 函数依赖 X&lt;/strong> ，记作$X \rightarrow Y$。&lt;/li>
&lt;li>完全函数依赖：如果Y函数依赖X，但不依赖X的任何一个真子集，则称&lt;strong>Y完全函数依赖X&lt;/strong>，记作$X \xrightarrow F Y$。&lt;/li>
&lt;li>部分函数依赖：如果Y函数依赖X，但依赖于X的任何一个真子集，则称&lt;strong>Y部分函数依赖X&lt;/strong>，记作$X \xrightarrow P Y$。&lt;/li>
&lt;li>传递函数依赖：设Z也是U的一个子集。如果X决定Y，Y决定Z，且&lt;strong>Y不决定X&lt;/strong>，那么称&lt;strong>Z对X传递函数依赖&lt;/strong>，记作$X \xrightarrow {传递} Y$。&lt;/li>
&lt;/ul>
&lt;h3 id="码键key">码/键(Key)&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>候选码：设属性集U包含关系模式内所有可能的属性值，K是U的子集，若$K\xrightarrow F U$，则称K为&lt;strong>候选码&lt;/strong>（K是一个集合！）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主码：候选码若有多个，则选定其中的一个，称为&lt;strong>主码&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>超码：对于属性集U，候选码K，若$K\xrightarrow P U$，则称K为&lt;strong>超码。&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主属性/非主属性：包含在任何一个候选码的属性都叫&lt;strong>主属性&lt;/strong>，其他都叫&lt;strong>非主属性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="范式normal-form">范式（Normal Form）&lt;/h3>
&lt;p>对于范式的概念，特别不靠谱的理解如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一范式(1NF)：不能出现类似excel中合并单元格的那种情形？（要求一个关系中的所有字段值都是不可分解的原子值）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二范式(2NF)：在满足1NF的基础上，还需要满足：在其他非主属性与主键的函数依赖关系中，主键集合中是作为&lt;strong>一个整体&lt;/strong>起到函数决定的作用的。反过来说，就是不能出现这样一种情况：主键中的某个主属性仅凭自身便能决定其它的非主属性，而函数决定其它的非主属性主键只有作为包含了（不存在非主属性对主键的部分函数依赖关系）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第三范式(3NF)：在满足2NF的基础上，对于一个关系内的非主属性，他们能且仅能被主键唯一地表示。换而言之，该关系模式内存在的函数依赖关系都是由主键所决定的。除了这些被主键决定的函数依赖关系之外，非主属性之间必须相互独立，再也不能出现其他的函数依赖关系。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BCNF: 在满足3NF的基础上，将“对于一个关系内的&lt;strong>非主&lt;/strong>属性，他们能且仅能被主键唯一地表示”成了“对于一个关系内的&lt;strong>所有&lt;/strong>属性，他们能且仅能被主键唯一地表示”，所需要满足的条件比3NF更加严格。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第四范式(4NF)：原关系模式中不存在非平凡的多值依赖。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="问题的引入数据异常及规范化理论">问题的引入——数据异常及规范化理论&lt;/h2>
&lt;p>当我们在设计数据库时，若我们考虑不当，将过多的要素全部塞进了一张单独的表时，那么后续操作这张表时可能会引发诸多意料之外的异常情况(anomality)，如：&lt;/p></description></item></channel></rss>