<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>工具::代码实现 on 狗蛋日</title>
        <link>https://young-mann.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</link>
        <description>Recent content in 工具::代码实现 on 狗蛋日</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <copyright>&amp;copy; 2021 &lt;a href=&#34;https://www.wangchucheng.com/&#34;&gt;WANG Chucheng&lt;/a&gt; and &lt;a href=&#34;https://www.ruiqima.com/&#34;&gt;MA Ruiqi&lt;/a&gt;
</copyright>
        <lastBuildDate>Thu, 20 Oct 2022 21:50:02 +0800</lastBuildDate><atom:link href="https://young-mann.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>蒙特卡罗估计简介</title>
        <link>https://young-mann.github.io/posts/mc/</link>
        <pubDate>Thu, 20 Oct 2022 21:50:02 +0800</pubDate>
        
        <guid>https://young-mann.github.io/posts/mc/</guid>
        <description>&lt;p&gt;本文是对&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/25727712/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《金融工程中的蒙特卡罗方法》&lt;/a&gt;一书的读书笔记。&lt;/p&gt;
&lt;h2 id=&#34;蒙特卡洛原理&#34;&gt;蒙特卡洛原理&lt;/h2&gt;
&lt;h3 id=&#34;蒙特卡洛方法是什么&#34;&gt;蒙特卡洛方法是什么？&lt;/h3&gt;
&lt;p&gt;蒙特卡罗方法是一种用于模拟随机现象，以求得事件的概率的统计模拟方法。借助测度论的语言，我们可对概率论做一种公理化定义&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，将随机试验中随机发生的事件与一个集合对应起来（这个集合包含了事件发生时的所有可能结果），将总体也与一个集合对应起来（这个集合包含了随机试验的所有可能结果），从而将概率定义为：&lt;/p&gt;
&lt;p&gt;$$某事件的概率 := \frac{该事件对应集合的容量}{总体对应集合的容量}$$&lt;/p&gt;
&lt;p&gt;确定了这个定义之后，我们便可以通过计算事件对应集合的容量与总体对应集合的容值，计算某个事件的概率——而实际上蒙特卡罗方法就是这么做的。比如，我们现在想要计算某个事件发生的概率。那么，我们可以做的是，在所有可能结果组成的总体中随机抽样，然后计算落入事件对应集合的样本点所占总体的比例，以此比例「估计」事件对应集合的容量。在这一过程中，大数定律保证了这个估计会随着抽样的增加而收敛于真实值&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，中心极限定理则给出了在有限次抽样下估计误差的可能幅度。&lt;/p&gt;
&lt;p&gt;为了更方便地计算集合的度量，我们可以引入积分这个工具。考虑一个简单的例子：假设我们现在需要估计一个给定函数$f$在单位区间上的积分值。为书写方便起见，我们可以将这个积分值记作 $\alpha$，则有：
$$
\alpha = \int^1_0f(x) \mathop{}!\mathrm{d}x.
$$
$\alpha$ 可以被看作期望值 $\mathbb{E}[f(U)]$，其中 $U \sim\text{Uniform}(0,1)$。假设我们可以在 $[0,1]$ 上独立均匀地抽样得到 $U_1,U_2,\cdots$，那么计算 $f$ 在这些样本点上的取值并求平均，便可得到欲求积分值的一个蒙特卡洛估计：
$$
\hat \alpha &lt;em&gt;n = \frac1n \sum^n&lt;/em&gt;{i=1}f(U_i).
$$
如果函数 $f$ 满足一些特定性质，我们就能得到一个误差较低的 $\alpha$ 估计值，并且可以显式地求出这个估计的误差值。&lt;/p&gt;
&lt;p&gt;先来看看 $\alpha$ 的具体估计取值。如果函数 $f$ 在 $[0,1]$ 上可积，那么根据强大数定律，有：
$$
当\ n \to \infty \ 时,\  \hat \alpha_n \stackrel{a.s.}  \longrightarrow \alpha.
$$
再来看看估计的误差值。如果函数 $f$ 平方可积，那么蒙特卡洛估计中的误差项 $\hat \alpha_n - \alpha$ 近似服从于 $\text{Normal}(0, {\sigma_f^2}/{ n})$，而且 $n$ 越大，这个误差项就越近似于上述的正态分布。需要补充的是，这个正态分布中的总体方差 $\sigma_f$ 定义如下：
$$
\sigma_f^2 = \int^1_0 (f(x)-\alpha)^2 \mathop{}!\mathrm{d}x.
$$
要注意的是，上述 $\sigma_f$ 定义里用到了 $\alpha$ ，而这是一个总体的真实值，通常是未知的，从而导致 $\sigma_f$ 也是未知的。为了解决这个问题，我们可以转而使用样本标准差 $s_f$ 来估计误差值：
$$
s_f = \sqrt {\frac 1 {n-1} \sum^n_{i=1} (f(U_i) - \hat \alpha_i)^2}.
$$
至此，我们得到一个误差较低的 $\hat \alpha _n$ 估计值，以及本次估计的误差值 $s_f$。&lt;/p&gt;
&lt;h3 id=&#34;蒙特卡洛估计的误差有多大&#34;&gt;蒙特卡洛估计的误差有多大？&lt;/h3&gt;
&lt;p&gt;在上一小节里，我们曾提到，蒙特卡洛估计中的误差值近似服从于 $\text{Normal}(0, {\sigma_f^2}/{ n})$。现在让我们进一步分析蒙特卡洛估计误差的分布。&lt;/p&gt;
&lt;p&gt;考察这个分布中的标准差 ${\sigma_f}/{\sqrt n}$，容易知道，若想在原有的基础上减少一半的标准差，就需要相当于原有样本点 4 倍数量的样本点；如果想要增加一个数量级的精度，就需要原有基础上 100 倍数量的样本点。更准确地来说，蒙特卡洛估计的误差以 $O(n^{-1/2})$ 的速度收敛。&lt;/p&gt;
&lt;p&gt;以 $O(n^{-1/2})$ 的速度收敛？这速度算快算慢？说实话，不算快。举个例子，假设此前提到的函数 $f$ 二阶连续可导，如果直接将 $n$ 个梯形面积之和作为定积分的估计值的话，这种估计的误差收敛速度为 $O(n^{-2})$，似乎更快：&lt;/p&gt;
&lt;p&gt;欸，既然有别的估计方法的误差收敛得比蒙特卡洛更快，那我们为什么还要学蒙特卡洛方法呢？&lt;/p&gt;
&lt;p&gt;答案是，蒙特卡罗方法的标准差收敛速度&lt;strong&gt;不会随着维度的增加而增加&lt;/strong&gt;。实际上，我们在上一节中所估计的积分可以推广到任何维度 $d$ 下 $[0,1]^d$ 上的积分。此时，对于蒙特卡罗方法而言，尽管函数 $f$ 与 相应的 $\sigma _f$ 会发生变化，但其标准差仍会保有 $\sigma _f / \sqrt n$ 的形式。换而言之，$O(n^{-1/2})$ 的收敛速度对任何维度 $d$ 都成立。相比之下，$d$ 维中利用梯形法则的误差为 $O(n^{-2/d})$，随着维度增加，收敛速度也会降低。&lt;/p&gt;
&lt;p&gt;这种优势在我们为衍生品定价时尤为重要。资产定价理论的一个重要假设是，在某些情况下，衍生品的价格可以表示为其期望值，从而将衍生品的定价简化成了期望值的计算工作。在此过程中，如果要将期望值写成积分形式，我们便会发现，它的维数很大，甚至是无限的。这个时候，我们用蒙特卡洛方法就比较好——它的收敛速度不会随着维度增加而增加。&lt;/p&gt;
&lt;h3 id=&#34;如何比较不同蒙特卡洛估计的好坏&#34;&gt;如何比较不同蒙特卡洛估计的好坏？&lt;/h3&gt;
&lt;p&gt;《金融工程中的蒙特卡罗方法》的第 4 章到第 6 章主要说明了如何改进蒙特卡洛估计，使其运行得更「好」。那么，这种「好」对应的评价标准是什么呢？在这一节里，我们介绍原书中提到的 3 个用于比较不同估计的评价标准：计算时间，偏差，以及方差。不严谨地讲，评价标准可被描述如下：&lt;/p&gt;
&lt;p&gt;在无偏估计下，在其它此处未被提及的条件均等价的情况下，如果 2 个不同估计量所需要的计算时间一致，那么我们选「方差更小」的估计量；如果所需要的计算时间有差别，且有更小方差的估计量需要更多的计算时间，那么我们选「每次重复实验的方差与每次重复实验的期望计算时间之积」最小的那个。&lt;/p&gt;
&lt;h4 id=&#34;无偏估计下的比较估计量的方差计算时间&#34;&gt;无偏估计下的比较——估计量的方差、计算时间&lt;/h4&gt;
&lt;p&gt;让我们来考虑最简单的无偏估计的情形。假定
$$
\hat C_n  = \frac 1 n \sum^n_{i=1}C_i,
$$
其中 $C_i$ 是独立同分布变量，$\mathbb{E}[C_i] = C$ 且 $\text{Var}[C_i] = \sigma_C &amp;lt; \infty$。由中心极限定理可知，随着重复次数 $n$ 的不断增大，标准估计值 $(\hat C_n - C)/(\sigma_C/\sqrt{n})$ 收敛于正态分布，即：
$$
\frac {(\hat C_n - C)} {(\sigma_C/\sqrt{n})} \Rightarrow \text{Normal}(0,1),
$$
或者等价于：
$$
{\sqrt n (\hat C_n - C)}  \Rightarrow \text{Normal}(0,\sigma_C^2).
$$
上面的「$\Rightarrow$」表示收敛于某个分布。从上式可推得：
$$
\lim_{n \to \infty} \mathop{P}\left(\frac {\hat C_n - C} {\sigma_C/\sqrt{n}} \leq x\right)  = \Phi(x)
$$
对于所有的 $x$ 成立。这个式子重要的地方在于，如果将 $\sigma_C$ 用样本标准差 $S_C$ 代替，那么这个极限依旧成立。&lt;/p&gt;
&lt;p&gt;再利用中心极限定理，可以近似地有：
$$
\hat C_n-C \approx \text{Normal}(0,\sigma_C^2/n).
$$
上式说明左边的误差近似地有右边的分布。根据这个结论，我们可以认为，在其他条件不变的情况下，比较同一值的两个估计量时，我们应该选择方差更小的估计量，使得估计误差尽量小。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;若想了解更多基于测度论的概率论的定义，可参考&lt;a class=&#34;link&#34; href=&#34;../%e6%a6%82%e7%8e%87%e8%ae%ba%e5%9f%ba%e7%a1%80/&#34; &gt;《基于测度论的概率论基础》&lt;/a&gt;一文。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;由此不难看出，蒙特卡罗方法体现了频率学派对于概率的观点。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43; design patterns and derivatives pricing</title>
        <link>https://young-mann.github.io/posts/design-patterns-and-derivatives-pricing/</link>
        <pubDate>Tue, 09 Aug 2022 00:42:05 +0800</pubDate>
        
        <guid>https://young-mann.github.io/posts/design-patterns-and-derivatives-pricing/</guid>
        <description>&lt;p&gt;&lt;strong&gt;Book Link:&lt;/strong&gt; &lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://neodb.social/books/493600/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;C++ Design Patterns and Derivatives Pricing&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文用于记录读完 &lt;a class=&#34;link&#34; href=&#34;https://neodb.social/books/493600/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;em&gt;C++ design patterns and derivatives pricing&lt;/em&gt;&lt;/a&gt; 后的代码实践。&lt;/p&gt;
&lt;h1 id=&#34;ch1-vanillacalloption&#34;&gt;ch1-VanillaCallOption&lt;/h1&gt;
&lt;p&gt;在第 1 章的文件夹里，主要实现了 1 个简单的看涨期权（call option）的定价模型，由 3 部分组成。主程序是 &lt;code&gt;SimpleMCMain1.cpp&lt;/code&gt; ，其中需要用到生成随机数的功能，所以引入了 1 个头文件（只有函数声明）的 &lt;code&gt;Random1.h&lt;/code&gt; ，以及具体实现该功能的头文件 &lt;code&gt;Random1_Implementation.h&lt;/code&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2022/10/09/CIUwl3ykpuzsQ8e.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;ch2-encapsulation&#34;&gt;ch2-Encapsulation&lt;/h1&gt;
&lt;p&gt;在第 2 章，对于常用的功能进行了封装。这章用到的文件具体如下（表格内省略了用于实现接口的文件，例如 “Random1_Implementation.h”，后文的表格皆是如此）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Random1.h&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;生成随机数的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PayOff1.h&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以 Strike 与 TheOptionsType 为私有变量的 PayOff 类，主要特点由：1. 以 &lt;code&gt;enum OptionType {call, put}&lt;/code&gt;  区分不同类型期权的定价方式（这里是 2 种：看涨期权、看跌期权）；2. 通过&lt;code&gt;double operator() (double Spot) const&lt;/code&gt; 重载运算符 &lt;code&gt;()&lt;/code&gt; ，以计算给定期权的 PayOff&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SimpleMC.h&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于最终定价的 Monte-Carlo 函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SimpleMCMain2.cpp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;主程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2022/10/09/TCehDSMZ6tal3zj.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;ch3-inheritanceandvirtualfunction&#34;&gt;ch3-InheritanceAndVirtualFunction&lt;/h1&gt;
&lt;p&gt;第 2 章的程序在扩展性上有待优化，考虑以下 2 个问题：&lt;/p&gt;
&lt;p&gt;第 1 个问题。如果我们现在希望引入 call, put 之外类型的期权，对其进行定价，那要怎么修改源程序呢？在上一章里，我们区分不同类型期权的 PayOff 利用了 &lt;code&gt;enum OptionType {call, put}&lt;/code&gt; ，因此很容易想到的一种方法是，直接向 OptionType 添加新的类型。但是，而这东西是定义在 PayOff 类里面的，如果我们想要添加新类型，那就得修改之前写过的代码，不利于后续的维护——我们更希望后续新增的代码能“即插即用”，不需要我们为了适配新功能而调整之前的代码。&lt;/p&gt;
&lt;p&gt;对于这个问题，本书的做法是采用&lt;strong&gt;继承&lt;/strong&gt;，将我们此前实现的 PayOff 类作为基类，衍生出新的子类，如 PayOffCall 类、PayOffPut 类。&lt;/p&gt;
&lt;p&gt;第 2 个问题，如果我们引入的新类型期权（比如 Double Digital Option），与之前的看涨期权、看跌期权都不一样，那怎么办？在上一章里，我们重载了运算符 &lt;code&gt;()&lt;/code&gt; 以输出给定期权的 PayOff，那我是不是可以对每一个衍生出来的期权类，都重写 1 个同名函数呢？不行。在已经采用&lt;strong&gt;继承&lt;/strong&gt;的方法下，这种思路会有些问题，不能子类与基类之间的“is-a”关系。以下面的代码为例，对于 1 个子类对象，能够调用出 2 种不同功能却同名的函数，会产生一致性问题&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class A 
{
    public:
        void foo();
};

class B : public A 
{
 public:
     void foo();
};

B instanceOfB;
A* ptrBase = &amp;amp;instanceOfB;
A* ptrDerived = &amp;amp;instanceOfB;

// 对于同一个类实例对象能调用出实现 2 种功能的同名函数
ptrBase -&amp;gt; foo(); // A::foo()
ptrDerived -&amp;gt; foo(); // B::foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么，如果对每一个衍生出来的期权类，我都在该类里重写一个新的计算 PayOff 的函数呢？也不行。比如，PayOffCall 类里写个 &lt;code&gt;CalPayOffCall()&lt;/code&gt;、PayOffPut 类里写个 &lt;code&gt;CalPayOffPut()&lt;/code&gt;？如果未来还需要引入其它新类型的期权，功能相同、但个个不同名的函数一多，维护起来太麻烦，所以这样也不太好。&lt;/p&gt;
&lt;p&gt;对于这个问题，本书的做法是采用&lt;strong&gt;虚函数&lt;/strong&gt;，在 PayOff 基类中，将 &lt;code&gt;operator()&lt;/code&gt; 与 析构函数 &lt;code&gt;~PayOff()&lt;/code&gt; 写成虚函数。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;引入&lt;strong&gt;继承&lt;/strong&gt;与&lt;strong&gt;虚函数&lt;/strong&gt;后，便可改写 PayOff 类，新增的文件有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件名称&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PayOff2.h&lt;/td&gt;
&lt;td&gt;在 PayOff1.h 的基础上，引入了继承与虚函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SimpleMC2.h&lt;/td&gt;
&lt;td&gt;改动了 &lt;code&gt;#include&lt;/code&gt; 的头文件，即 PayOff2.h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SimpleMCMain3.cpp&lt;/td&gt;
&lt;td&gt;新的主程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;此外，通过继承，我们便可实现“即插即用”。本章引入了 DoubleDigital 类作为示例。新增的文件如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名称&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SimpleMCMain4.cpp&lt;/td&gt;
&lt;td&gt;在 SimpleMCMain3.cpp 的基础上，利用 if 判断期权的类型（是call？还是 put？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DoubleDigital.h&lt;/td&gt;
&lt;td&gt;基于 PayOff 所衍生出的 PayOffDoubleDigital 子类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SimpleMCMain5.cpp&lt;/td&gt;
&lt;td&gt;计算 DoubleDigital 期权的主程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;与原书相比，对于“实现接口功能”的文件的命名上，笔者采用了另外的方式。以 Random1 为例，原书中对于接口文件与实现文件的命名分别是 Random1.h 、Random1.cpp。而本仓库中则以 Random1.h 、Random1_Implementation.h 的方式命名。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;不过，这个问题其实在 PayOff 类里并不会出现，但为了设计的一致性，还是需要避免。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        
    </channel>
</rss>
