<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数据库 on 狗蛋日</title>
        <link>https://young-mann.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
        <description>Recent content in 数据库 on 狗蛋日</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <copyright>&amp;copy; 2021 &lt;a href=&#34;https://www.wangchucheng.com/&#34;&gt;WANG Chucheng&lt;/a&gt; and &lt;a href=&#34;https://www.ruiqima.com/&#34;&gt;MA Ruiqi&lt;/a&gt;
</copyright>
        <lastBuildDate>Tue, 18 May 2021 19:31:10 +0800</lastBuildDate><atom:link href="https://young-mann.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>关系数据理论</title>
        <link>https://young-mann.github.io/posts/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</link>
        <pubDate>Tue, 18 May 2021 19:31:10 +0800</pubDate>
        
        <guid>https://young-mann.github.io/posts/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</guid>
        <description>&lt;p&gt;本文是《数据库系统概论》的第6章以及“Database System: The Complete Book”的第三章所作的部分笔记，用以理解数据库设计过程中的关系数据理论。笔者认为，在这些教材中，对于关系数据理论的阐释可被归结为对于以下几个问题的回应：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个糟糕的数据库设计是什么样的，又会为使用者带来多少麻烦？&lt;strong&gt;（问题的引入）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;是否存在某些可以遵循的准则，帮助我们设计出“不那么糟糕”的数据库？&lt;strong&gt;（规范化理论）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在了解“不那么糟糕的数据库应该是什么样的”之后，我们又能采取哪些措施，让我们在设计数据库时满足这些让数据库运作得更好的条件？&lt;strong&gt;（Armstrong公理&amp;amp;模式分解）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;预备知识&#34;&gt;预备知识&lt;/h2&gt;
&lt;p&gt;为了更好地理解下文的内容，读者首先需要掌握关系数据理论中的部分基本概念：&lt;/p&gt;
&lt;h3 id=&#34;函数依赖functional-dependency&#34;&gt;函数依赖(Functional Dependency)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;**函数依赖：**设 R(U) 是属性集U的关系模型, X, Y是U的一个子集, 对于 R(U) 中的任一个关系 r, 不可能存在两个元组在 X 上属性值相同, 而在 Y 上属性值不同。则称 &lt;strong&gt;X 函数确定 Y&lt;/strong&gt; , 或 &lt;strong&gt;Y 函数依赖 X&lt;/strong&gt; ，记作$X \rightarrow  Y$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完全函数依赖：&lt;strong&gt;如果Y函数依赖X，但不依赖X的任何一个真子集，则称&lt;/strong&gt;Y完全函数依赖X&lt;/strong&gt;，记作$X \xrightarrow F Y$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部分函数依赖：&lt;strong&gt;如果Y函数依赖X，但依赖于X的任何一个真子集，则称&lt;/strong&gt;Y部分函数依赖X&lt;/strong&gt;，记作$X \xrightarrow P Y$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递函数依赖：&lt;strong&gt;设Z也是U的一个子集。如果X决定Y，Y决定Z，且&lt;/strong&gt;Y不决定X&lt;/strong&gt;，那么称&lt;strong&gt;Z对X传递函数依赖&lt;/strong&gt;，记作$X \xrightarrow {传递} Y$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;码键key&#34;&gt;码/键(Key)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;候选码：&lt;strong&gt;设属性集U包含关系模式内所有可能的属性值，K是U的子集，若$K\xrightarrow F U$，则称K为&lt;/strong&gt;候选码&lt;/strong&gt;（K是一个集合！）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主码：&lt;strong&gt;候选码若有多个，则选定其中的一个，称为&lt;/strong&gt;主码&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;超码：&lt;strong&gt;对于属性集U，候选码K，若$K\xrightarrow P U$，则称K为&lt;/strong&gt;超码。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主属性/非主属性：&lt;strong&gt;包含在任何一个候选码的属性都叫&lt;/strong&gt;主属性&lt;/strong&gt;，其他都叫&lt;strong&gt;非主属性&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;范式normal-form&#34;&gt;范式（Normal Form）&lt;/h3&gt;
&lt;p&gt;对于范式的概念，特别不靠谱的理解如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**第一范式(1NF)：**不能出现类似excel中合并单元格的那种情形？（要求一个关系中的所有字段值都是不可分解的原子值）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第二范式(2NF)：&lt;strong&gt;在满足1NF的基础上，还需要满足：在其他非主属性与主键的函数依赖关系中，主键集合中是作为&lt;/strong&gt;一个整体&lt;/strong&gt;起到函数决定的作用的。反过来说，就是不能出现这样一种情况：主键中的某个主属性仅凭自身便能决定其它的非主属性，而函数决定其它的非主属性主键只有作为包含了（不存在非主属性对主键的部分函数依赖关系）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**第三范式(3NF)：**在满足2NF的基础上，对于一个关系内的非主属性，他们能且仅能被主键唯一地表示。换而言之，该关系模式内存在的函数依赖关系都是由主键所决定的。除了这些被主键决定的函数依赖关系之外，非主属性之间必须相互独立，再也不能出现其他的函数依赖关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BCNF:&lt;/strong&gt; 在满足3NF的基础上，将“对于一个关系内的&lt;strong&gt;非主&lt;/strong&gt;属性，他们能且仅能被主键唯一地表示”成了“对于一个关系内的&lt;strong&gt;所有&lt;/strong&gt;属性，他们能且仅能被主键唯一地表示”，所需要满足的条件比3NF更加严格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**第四范式(4NF)：**原关系模式中不存在非平凡的多值依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;问题的引入数据异常及规范化理论&#34;&gt;问题的引入——数据异常及规范化理论&lt;/h2&gt;
&lt;p&gt;当我们在设计数据库时，若我们考虑不当，将过多的要素全部塞进了一张单独的表时，那么后续操作这张表时可能会引发诸多意料之外的异常情况(anomality)，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据冗余 (Redundancy) ：在某些元组中，部分信息会重复出现，占用了不必要的存储空间。&lt;/li&gt;
&lt;li&gt;更新异常 (Update Anomalities) ：在更新该表中的信息时，可能导致数据库中的数据不一致。&lt;/li&gt;
&lt;li&gt;删除异常 (Deletion Anomalities) ：在删除某个元组的信息时，可能删除其它不应该删除的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于&lt;del&gt;笔者太懒&lt;/del&gt;异常操作的例子实在过于常见的缘故，笔者在此便不列举具体的例子了。我们更关心的是，这些异常背后到底意味着关系模式设计中的哪些不良性质？&lt;/p&gt;
&lt;p&gt;在第2小节里，我们将了解如何通过&lt;strong&gt;函数依赖&lt;/strong&gt;描述一个关系模式。将借助&lt;strong&gt;函数依赖&lt;/strong&gt;刻画关系模式的&lt;strong&gt;规范化程度&lt;/strong&gt;，根据该关系模式属性之间的依赖程度，将该关系模式区分为某一种特定范式，以甄别该关系模式中是否存在引发上述问题的糟糕性质。接着，在第3小节内，我们将了解如何根据特定的&lt;strong&gt;规范化程度&lt;/strong&gt;，对于关系模式进行&lt;strong&gt;规范化&lt;/strong&gt;，将具有糟糕性质的关系模式转化为更合适的形式。
一个设计不当的数据库在操作时之所以会出现那么多异常，其根源在于我们在设计关系模式时忽视了不恰当的部分/传递函数依赖（无论是有意的，还是无意的）。如果我们能事先识别出关系模式中出现的所有可能的函数依赖，那不就可以直接把那些不恰当的函数依赖挑出来，把它们扼杀在摇篮里了吗？规范化的基本思想可被归结为**“一事一地”**，即让每一个关系只描述一个概念、一个实体或者实体之间的联系。这种规范化，可以通过模式分解的手段完成，将低一级的关系模式分解为多个高一级的关系模式，从而消除关系模式中不合适的数据依赖关系。&lt;/p&gt;
&lt;p&gt;对这个问题换一个更为具体的表述，那便成了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定关系模式R &amp;lt;U, F&amp;gt;以及函数依赖集F的前提下，是否存在一种方法，which能帮助我们找出&lt;b&gt;该关系模式中被F逻辑蕴含的函数依赖的全体&lt;/b&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，通过定义&lt;strong&gt;逻辑蕴含&lt;/strong&gt;的概念，以准确的刻画出问题的定义。然而，在描述完上面这个问题以后，我们还是一筹莫展——光从这个定义本身而言，我们得不到什么有用的信息，有助于求解该问题。于是，机智的老哥们曲线救国，试着以全新的角度解读这个问题，重新构造了一个推理系统，即Armstrong公理，在逻辑上证明了“逻辑蕴含”与“根据Armstrong公理进行推导”这两个操作之间是等价的（有效性与完备性的证明）。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
