<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>C&#43;&#43; on 狗蛋日</title>
        <link>https://young-mann.github.io/tags/c&#43;&#43;/</link>
        <description>Recent content in C&#43;&#43; on 狗蛋日</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <copyright>&amp;copy; 2021 &lt;a href=&#34;https://www.wangchucheng.com/&#34;&gt;WANG Chucheng&lt;/a&gt; and &lt;a href=&#34;https://www.ruiqima.com/&#34;&gt;MA Ruiqi&lt;/a&gt;
</copyright>
        <lastBuildDate>Tue, 09 Aug 2022 00:42:05 +0800</lastBuildDate><atom:link href="https://young-mann.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43; design patterns and derivatives pricing</title>
        <link>https://young-mann.github.io/posts/design-patterns-and-derivatives-pricing/</link>
        <pubDate>Tue, 09 Aug 2022 00:42:05 +0800</pubDate>
        
        <guid>https://young-mann.github.io/posts/design-patterns-and-derivatives-pricing/</guid>
        <description>&lt;p&gt;&lt;strong&gt;Book Link:&lt;/strong&gt; &lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://neodb.social/books/493600/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;C++ Design Patterns and Derivatives Pricing&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文用于记录读完 &lt;a class=&#34;link&#34; href=&#34;https://neodb.social/books/493600/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;em&gt;C++ design patterns and derivatives pricing&lt;/em&gt;&lt;/a&gt; 后的代码实践。&lt;/p&gt;
&lt;h1 id=&#34;ch1-vanillacalloption&#34;&gt;ch1-VanillaCallOption&lt;/h1&gt;
&lt;p&gt;在第 1 章的文件夹里，主要实现了 1 个简单的看涨期权（call option）的定价模型，由 3 部分组成。主程序是 &lt;code&gt;SimpleMCMain1.cpp&lt;/code&gt; ，其中需要用到生成随机数的功能，所以引入了 1 个头文件（只有函数声明）的 &lt;code&gt;Random1.h&lt;/code&gt; ，以及具体实现该功能的头文件 &lt;code&gt;Random1_Implementation.h&lt;/code&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2022/10/09/CIUwl3ykpuzsQ8e.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;ch2-encapsulation&#34;&gt;ch2-Encapsulation&lt;/h1&gt;
&lt;p&gt;在第 2 章，对于常用的功能进行了封装。这章用到的文件具体如下（表格内省略了用于实现接口的文件，例如 “Random1_Implementation.h”，后文的表格皆是如此）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Random1.h&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;生成随机数的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PayOff1.h&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以 Strike 与 TheOptionsType 为私有变量的 PayOff 类，主要特点由：1. 以 &lt;code&gt;enum OptionType {call, put}&lt;/code&gt;  区分不同类型期权的定价方式（这里是 2 种：看涨期权、看跌期权）；2. 通过&lt;code&gt;double operator() (double Spot) const&lt;/code&gt; 重载运算符 &lt;code&gt;()&lt;/code&gt; ，以计算给定期权的 PayOff&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SimpleMC.h&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于最终定价的 Monte-Carlo 函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SimpleMCMain2.cpp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;主程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2022/10/09/TCehDSMZ6tal3zj.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;ch3-inheritanceandvirtualfunction&#34;&gt;ch3-InheritanceAndVirtualFunction&lt;/h1&gt;
&lt;p&gt;第 2 章的程序在扩展性上有待优化，考虑以下 2 个问题：&lt;/p&gt;
&lt;p&gt;第 1 个问题。如果我们现在希望引入 call, put 之外类型的期权，对其进行定价，那要怎么修改源程序呢？在上一章里，我们区分不同类型期权的 PayOff 利用了 &lt;code&gt;enum OptionType {call, put}&lt;/code&gt; ，因此很容易想到的一种方法是，直接向 OptionType 添加新的类型。但是，而这东西是定义在 PayOff 类里面的，如果我们想要添加新类型，那就得修改之前写过的代码，不利于后续的维护——我们更希望后续新增的代码能“即插即用”，不需要我们为了适配新功能而调整之前的代码。&lt;/p&gt;
&lt;p&gt;对于这个问题，本书的做法是采用&lt;strong&gt;继承&lt;/strong&gt;，将我们此前实现的 PayOff 类作为基类，衍生出新的子类，如 PayOffCall 类、PayOffPut 类。&lt;/p&gt;
&lt;p&gt;第 2 个问题，如果我们引入的新类型期权（比如 Double Digital Option），与之前的看涨期权、看跌期权都不一样，那怎么办？在上一章里，我们重载了运算符 &lt;code&gt;()&lt;/code&gt; 以输出给定期权的 PayOff，那我是不是可以对每一个衍生出来的期权类，都重写 1 个同名函数呢？不行。在已经采用&lt;strong&gt;继承&lt;/strong&gt;的方法下，这种思路会有些问题，不能子类与基类之间的“is-a”关系。以下面的代码为例，对于 1 个子类对象，能够调用出 2 种不同功能却同名的函数，会产生一致性问题&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class A 
{
    public:
        void foo();
};

class B : public A 
{
 public:
     void foo();
};

B instanceOfB;
A* ptrBase = &amp;amp;instanceOfB;
A* ptrDerived = &amp;amp;instanceOfB;

// 对于同一个类实例对象能调用出实现 2 种功能的同名函数
ptrBase -&amp;gt; foo(); // A::foo()
ptrDerived -&amp;gt; foo(); // B::foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么，如果对每一个衍生出来的期权类，我都在该类里重写一个新的计算 PayOff 的函数呢？也不行。比如，PayOffCall 类里写个 &lt;code&gt;CalPayOffCall()&lt;/code&gt;、PayOffPut 类里写个 &lt;code&gt;CalPayOffPut()&lt;/code&gt;？如果未来还需要引入其它新类型的期权，功能相同、但个个不同名的函数一多，维护起来太麻烦，所以这样也不太好。&lt;/p&gt;
&lt;p&gt;对于这个问题，本书的做法是采用&lt;strong&gt;虚函数&lt;/strong&gt;，在 PayOff 基类中，将 &lt;code&gt;operator()&lt;/code&gt; 与 析构函数 &lt;code&gt;~PayOff()&lt;/code&gt; 写成虚函数。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;引入&lt;strong&gt;继承&lt;/strong&gt;与&lt;strong&gt;虚函数&lt;/strong&gt;后，便可改写 PayOff 类，新增的文件有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件名称&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PayOff2.h&lt;/td&gt;
&lt;td&gt;在 PayOff1.h 的基础上，引入了继承与虚函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SimpleMC2.h&lt;/td&gt;
&lt;td&gt;改动了 &lt;code&gt;#include&lt;/code&gt; 的头文件，即 PayOff2.h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SimpleMCMain3.cpp&lt;/td&gt;
&lt;td&gt;新的主程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;此外，通过继承，我们便可实现“即插即用”。本章引入了 DoubleDigital 类作为示例。新增的文件如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名称&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SimpleMCMain4.cpp&lt;/td&gt;
&lt;td&gt;在 SimpleMCMain3.cpp 的基础上，利用 if 判断期权的类型（是call？还是 put？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DoubleDigital.h&lt;/td&gt;
&lt;td&gt;基于 PayOff 所衍生出的 PayOffDoubleDigital 子类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SimpleMCMain5.cpp&lt;/td&gt;
&lt;td&gt;计算 DoubleDigital 期权的主程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;与原书相比，对于“实现接口功能”的文件的命名上，笔者采用了另外的方式。以 Random1 为例，原书中对于接口文件与实现文件的命名分别是 Random1.h 、Random1.cpp。而本仓库中则以 Random1.h 、Random1_Implementation.h 的方式命名。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;不过，这个问题其实在 PayOff 类里并不会出现，但为了设计的一致性，还是需要避免。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        
    </channel>
</rss>
