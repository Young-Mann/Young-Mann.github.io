<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>我小子又在抄教材了！ on 狗蛋日</title>
    <link>https://young-mann.top/tags/%E6%88%91%E5%B0%8F%E5%AD%90%E5%8F%88%E5%9C%A8%E6%8A%84%E6%95%99%E6%9D%90%E4%BA%86/</link>
    <description>Recent content in 我小子又在抄教材了！ on 狗蛋日</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 16 May 2023 20:25:00 +0800</lastBuildDate>
    <atom:link href="https://young-mann.top/tags/%E6%88%91%E5%B0%8F%E5%AD%90%E5%8F%88%E5%9C%A8%E6%8A%84%E6%95%99%E6%9D%90%E4%BA%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>对无套利定价的一点理解</title>
      <link>https://young-mann.top/posts/%E6%97%A0%E5%A5%97%E5%88%A9/</link>
      <pubDate>Tue, 16 May 2023 20:25:00 +0800</pubDate>
      <guid>https://young-mann.top/posts/%E6%97%A0%E5%A5%97%E5%88%A9/</guid>
      <description>在课本上看到套利定价模型和衍生品定价的时候，总会看到无套利定价的思路。尽管其思想很容易理解，但还是很好奇为什么特意要强调这种定价方法呢？另外，这种定价方法和以前提出的定价方法比，又有什么好处呢？对于定价理论的发展史稍作了解后，我目前的结论是，无套利定价理论更加实用，因为它所需要的前提假设更宽松，不需要假设决策者的效用函数，which 过于理想化、缺乏统一的设定标准、但在均衡定价方法中又是必须的。&#xA;无套利定价理论的出现，得从金融产品的定价开始说起。&#xA;早期做金融产品定价的多是经济学出身的学者。而在经济学里，主流的定价方法是均衡定价，即认为，市场出清时的均衡价格，也就是需求和供给达到均衡时的价格就是该产品应有的价格。而需求和供给又可以从消费者理论与生产者理论分别推出：在给定消费者偏好与预算约束的情况下， 消费者的效用最大化决定了需求曲线；同理，生产者的利润最大化决定了需求曲线。把两条曲线放在一起，它们的交点就是均衡点，此状态下的价格便是均衡价格。&#xA;在面对金融产品定价这个问题的时候，这些学者也曾试着用上述的传统手段进行定价，但是很快就遇上了麻烦：金融产品和此前研究的产品不太一样。此前研究的产品，比如说冰淇淋，它的供给方与需求方是两拨人，但金融市场上，买卖产品的却是同一拨人，供给方和需求方是一体的。这样下来，原本消费者理论的效用最大化、生产者理论的利润最大化便很难在此得到推广，供给需求曲线也画不出来了，更别提能不能得到均衡价格了。&#xA;对于金融产品，既然搞不出传统供给需求的均衡，也就是局部均衡了，那还能咋整呢？Arrow 和 Debreu 俩老哥就想出了新路子，给市场里的每个人加上了当期和未来的消费的效用函数，再对效用函数做最优化，以此得到需求量。这条思路被称为一般均衡定价。&#xA;新的均衡理论有是有了，但问题是它不实用啊，没法用在实际的金融产品交易中。这是因为，一般均衡理论很大程度上依赖于每个人的「效用函数」的假设——经济学家对「效用函数」做了一系列的假设，比如单调性、凸性、连续性，但具体怎么设定效用函数，却没个统一的标准。&#xA;这可咋整？效用函数在理论推导上是挺有用，但我用不上啊——我总不能在每次下单前都显式地写出自己的效用函数吧？那么，能不能绕开效用函数，对金融产品进行定价呢？这就得提到另一套定价理论，几乎不依赖对效用函数的假设。这个定价理论叫无套利定价。它的思路很简单，把金融产品还原成不同比例的基础资产，把这些基础资产的价格加总起来，就是金融产品的价格了。比如说，如果我想要对一个双层吉士汉堡进行定价，那我只要把双吉里面包、牛肉饼、知识、番茄酱、酸黄瓜、洋葱碎的占比和它们的价格记下来，根据不同成分的占比加权求和，再加点服务费，就能知道双吉的价格了1。&#xA;用数学语言来讲，无套利方法其实就是把衍生品投影到商品空间的一组基上，用投影的系数和这些基的价格做个加权和。换个角度来看，无套利定价也可以被认为是商品空间里的泰勒展开。只要能够找到基础资产，就能对衍生品进行定价。而在金融市场中，最常见的基础资产有股票和现金2。因此，后来的学者就想方设法把衍生品拆成股票和现金的组合。其中，Merton 就将欧式看涨期权拆成了 $\Delta$ 份股票和 $-\Pi$ 份现金的组合，即：$call=\Delta \times S-\Pi$，并利用现金可以生息的特性，从 $d\Pi = r\Pi dt$ 这个微分方程出发，利用伊藤引理推导出了期权价格满足的微分方程，后人称 B-S 方程。&#xA;再之后，各式各样的微分方程出现在了衍生品的研究和实务领域，但是解这些微分方程也是挺折磨人的事情。于是，后来人在完全市场的假设下搞了等价鞅测度，将相对价格表示为了一个期望值，并进一步化简，将其表示为了风险中性概率下 payoff 的折现值，即：$f=\mathbb E^Q[e^{-\int rdt}f_T]$，大大简化了衍生品定价的计算。&#xA;(2023/11/01 更新：下文用到的符号均取自 Mathematical Foundations for Finance)&#xA;现在回头来看，之前的最后一段存在问题：等价鞅测度不是在先有完备市场的假设下被搞出来的。实际上，我们是先检查市场 $\left(\Omega, \mathcal{F}, \mathbb{F}, P, S^0 \equiv 1, S\right)$的等价鞅测度，来判断这个市场是否满足无套利，并且（进一步而言）是完备的？ 等价鞅测度、无套利、完备三者的关系大概可被表述为：如果市场$S$有至少一个等价鞅测度，那么该市场满足无套利；在此基础上，如果市场$S$有且仅有一个等价鞅测度，那么该市场是完备的。下图是讲义中的相关定理，其中$S^0$是作为 numéraire 的资产的价格，$\mathbb{P}_e$表示 $S$ 的所有等价鞅测度所组成的集合。&#xA;无套利和等价鞅测度的关系&#xA;无套利、完备和等价鞅测度的关系&#xA;根据定义，如果一个市场满足无套利却不是完备的，那么，市场里必定存在一些无法复制的 payoff。这意味着，我们无法对部分资产定出唯一的价格。不同的等价鞅测度，会导致资产被定出不同价格。反之，如果市场是完备的，那么我们就能确保市场里每个资产都能被给定唯一的价格，无论我们采用哪一个等价鞅测度。此时，以下的风险中性定价公式就能成立，大大简化了对于期权的定价：&#xA;风险中性定价公式&#xA;欸，那么面包、牛肉饼、知识、番茄酱、酸黄瓜、洋葱碎的价格是多少？这个我不知道，因为它们都是基础资产，而无套利方法只能对由这些基础资产衍生而来的衍生资产做定价。换而言之，无套利定价是一种相对定价方法。与之相对的概念是绝对定价方法，简单来说，是指将某资产的未来现金流折现加总值认为是该资产的价格。&amp;#160;&amp;#x21a9;&amp;#xfe0e;&#xA;债券不是基础资产——它可以被认为是利率的衍生品，而且是最简洁的衍生品。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    <item>
      <title>金融数学中sigma代数的直观含义</title>
      <link>https://young-mann.top/posts/sigma%E4%BB%A3%E6%95%B0%E7%9A%84%E7%9B%B4%E8%A7%82%E5%90%AB%E4%B9%89/</link>
      <pubDate>Tue, 16 May 2023 14:31:37 +0800</pubDate>
      <guid>https://young-mann.top/posts/sigma%E4%BB%A3%E6%95%B0%E7%9A%84%E7%9B%B4%E8%A7%82%E5%90%AB%E4%B9%89/</guid>
      <description>sigma 代数表示的事件域代表每个阶段所知信息的多寡 简单来说，sigma 代数刻画的事件域 $\mathcal F$ 包含了一系列划分后的集合，后文称作「分类」，which 可以被我们用来对样本空间 $\Omega$ 中的样本路径 $\omega$ 进行归类。这些分类，实际上表示我们对于当前样本路径的了解程度：我们在某一阶段 $T$ 所知道的信息越多，这一阶段的事件域 $\mathcal F _T$ 所包含的元素就越多，表示我们 $\omega$ 所能采用的分类也就越多。&#xA;这些分类是怎样描述「所知道的信息」的？一种可行的思路是思路是，对于某个随机过程，我们会面临一条事前确定的样本路径 $\omega_i$ 。然而，尽管这条样本路径是已经被「固定」的，但我们并不知道 $\omega_i$ 是 $\Omega$ 中的哪一个 $\omega$ ——我们仅能知道，对于给定的 $\Omega$ 的某个子集，$\omega_i$ 是不是在这个子集里面。而前一句中 能够被判断是否包含 $\omega_i$ 的这些 $\Omega$ 的子集，就是我们在第一段中提到的，事件域 $\mathcal F$ 所包含的「分类」。如果对集合的划分越精细，「分类」就越多，表示我们知道的信息就更多。&#xA;一个例子 对于分类如何刻画信息，现在就来举个直观的例子。假设我现在要扔一枚质地均匀的硬币，扔个 2 次。将硬币的某一面记作正面，与其相反的一面记作反面。将「硬币投出了正面」记作 H （假设其可能性为 $p,p&amp;gt;0$ ），将「硬币投出了反面」记作 T （假设其可能性为 0&amp;quot;&amp;gt;$q, q=1-p&amp;gt;0$ ）。以一串序列 $\omega$ （其中 $\omega=\omega_1\omega_2$ ， 的可能取值为或$\omega_i的可能取值为H或T$ ）列出所有可能发生的结果，便可得样本空间 $\Omega = \lbrace \text{HH, HT, TH, TT}\rbrace.$&#xA;再定义一个随机变量 $S$ ，用于表示股票价格：&#xA;$$ \begin{align} S_0(\omega) &amp;amp;= 4, \forall \omega \in \Omega \\ S_1(\omega) &amp;amp;= \begin{cases} 8, &amp;amp; 如果 \omega_1=H \ 2, &amp;amp; 如果 \omega_1=T \ \end{cases} \\ S_2(\omega) &amp;amp;= \begin{cases} 16, &amp;amp; 如果 \omega_1=\omega_2=H \ 4, &amp;amp; 如果 \omega_1\neq \omega_2 \ 1, &amp;amp; 如果 \omega_1=\omega_2=T \end{cases} \end{align} $$</description>
    </item>
    <item>
      <title>侃侃「贷款创造理论」</title>
      <link>https://young-mann.top/posts/%E8%B4%B7%E6%AC%BE%E5%88%9B%E9%80%A0%E7%90%86%E8%AE%BA/</link>
      <pubDate>Fri, 21 Oct 2022 17:02:58 +0800</pubDate>
      <guid>https://young-mann.top/posts/%E8%B4%B7%E6%AC%BE%E5%88%9B%E9%80%A0%E7%90%86%E8%AE%BA/</guid>
      <description>在《货币创造的逻辑形成和历史演进——对传统货币理论的批判》一文里，孙国峰总结了「贷款创造存款」理论（loan creates deposit, LCD）的逻辑以及发展。&#xA;LCD 的内涵1包括：第一，货币创造是「银行放贷行为」本身，而不是传统教科书中所说的「先有存款进银行，银行再拿这笔钱放贷，就这样存了贷、贷了继续存」。第二，银行放贷是银行与客户的债权债务交换行为，其中，银行获得贷款债权，客户获得存款债权。第三，客户需付出额外的利差才可获取存款债权。客户之所以愿意接受利差，是因为其从银行获得的存款债权也被其他人认可，转移起来比较方便。这样的存款债权，就可成为信用货币。这种信用货币，并不是一种作为基础物质存在的实物「货币金额」，而是债权债务关系的的反映，是在记录这种债权债务关系、存款贷款同时出现的过程中「无中生有」的。相比之下，货币银行理论认为，在每一笔存款与每一笔贷款之间，都是有实实在在的「货币金额」为内容的经济行为，并没有任何「凭空创造」的意思。第四，为了支持贷款创造货币的行为，银行需要持有基础货币。&#xA;下面来举一个简单的例子，从资产负债表的角度说明 LCD 与传统货币银行理论在货币创造上的解释有所不同。&#xA;假设法定存款准备金率为 20 %，客户将现金存入银行后不会提现。第一家银行（记作 A）首先吸收了 100 元的「原始存款」，其中 20 元用于「缴存存款准备金」，剩下的 80 元放贷。客户得到了 80 元贷款后，用于支付给另一个客户，而这个新客户会将 80 元存入另一家银行（记作 B）。银行 B 再缴存 16元存款准备金后，再放贷 64 元。经历了这 2 个步骤后，银行 A 与银行 B 的资产负债表如下图所示。经历如此这般「存款-贷款-再存款-再放贷」的一轮轮接力后，最初存入银行的 100 元的「原始存款」全部变成准备金，再也无法拿出去放贷。此时，计算银行总体的资产负债表，会发现负债端有 500 元存款，资产端有 400 元贷款和 100 元准备金。&#xA;然而，在 LCD 这里，第 2 布的资产负债表就不太一样了。不同之处在于，在银行 A 放出一笔 80 元的新贷款的时候，就已经创造出了新的 80 元存款货币（也就是资产端&#x9;下方新出现的 80 元现金），并在此时向中央银行存入 16 元作为存款准备金。如果客户在贷款后继续购买商品，那么银行 A 与银行 B 的资产负债表还会发生变化，但这个变化的过程已经和传统货币银行理论中所描述的不一样了。&#xA;若想了解更多孙国峰对 LCD 的阐释，可见孙国峰（2019）。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    <item>
      <title>蒙特卡罗估计简介</title>
      <link>https://young-mann.top/posts/monte-carlo/</link>
      <pubDate>Thu, 20 Oct 2022 21:50:02 +0800</pubDate>
      <guid>https://young-mann.top/posts/monte-carlo/</guid>
      <description>本文是对《金融工程中的蒙特卡罗方法》一书的读书笔记。&#xA;蒙特卡洛原理 蒙特卡洛方法是什么？ 蒙特卡罗方法是一种用于模拟随机现象，以求得事件的概率的统计模拟方法。借助测度论的语言，我们可对概率论做一种公理化定义1，将随机试验中随机发生的事件与一个集合对应起来（这个集合包含了事件发生时的所有可能结果），将总体也与一个集合对应起来（这个集合包含了随机试验的所有可能结果），从而将概率定义为：&#xA;$$某事件的概率 := \frac{该事件对应集合的容量}{总体对应集合的容量}$$&#xA;确定了这个定义之后，我们便可以通过计算事件对应集合的容量与总体对应集合的容值，计算某个事件的概率——而实际上蒙特卡罗方法就是这么做的。比如，我们现在想要计算某个事件发生的概率。那么，我们可以做的是，在所有可能结果组成的总体中随机抽样，然后计算落入事件对应集合的样本点所占总体的比例，以此比例「估计」事件对应集合的容量。在这一过程中，大数定律保证了这个估计会随着抽样的增加而收敛于真实值2，中心极限定理则给出了在有限次抽样下估计误差的可能幅度。&#xA;为了更方便地计算集合的度量，我们可以引入积分这个工具。考虑一个简单的例子：假设我们现在需要估计一个给定函数$f$在单位区间上的积分值。为书写方便起见，我们可以将这个积分值记作 $\alpha$，则有： $$ \alpha = \int^1_0f(x) \mathop{}!\mathrm{d}x. $$ $\alpha$ 可以被看作期望值 $\mathbb{E}[f(U)]$，其中 $U \sim\text{Uniform}(0,1)$。假设我们可以在 $[0,1]$ 上独立均匀地抽样得到 $U_1,U_2,\cdots$，那么计算 $f$ 在这些样本点上的取值并求平均，便可得到欲求积分值的一个蒙特卡洛估计： $$ \hat \alpha n = \frac1n \sum^n{i=1}f(U_i). $$ 如果函数 $f$ 满足一些特定性质，我们就能得到一个误差较低的 $\alpha$ 估计值，并且可以显式地求出这个估计的误差值。&#xA;先来看看 $\alpha$ 的具体估计取值。如果函数 $f$ 在 $[0,1]$ 上可积，那么根据强大数定律，有： $$ 当\ n \to \infty \ 时,\ \hat \alpha_n \stackrel{a.s.} \longrightarrow \alpha. $$ 再来看看估计的误差值。如果函数 $f$ 平方可积，那么蒙特卡洛估计中的误差项 $\hat \alpha_n - \alpha$ 近似服从于 $\text{Normal}(0, {\sigma_f^2}/{ n})$，而且 $n$ 越大，这个误差项就越近似于上述的正态分布。需要补充的是，这个正态分布中的总体方差 $\sigma_f$ 定义如下： $$ \sigma_f^2 = \int^1_0 (f(x)-\alpha)^2 \mathop{}!</description>
    </item>
    <item>
      <title>C&#43;&#43; design patterns and derivatives pricing</title>
      <link>https://young-mann.top/posts/design-patterns-and-derivatives-pricing/</link>
      <pubDate>Tue, 09 Aug 2022 00:42:05 +0800</pubDate>
      <guid>https://young-mann.top/posts/design-patterns-and-derivatives-pricing/</guid>
      <description>Book Link: C++ Design Patterns and Derivatives Pricing&#xA;本文用于记录读完 C++ design patterns and derivatives pricing 后的代码实践。&#xA;ch1-VanillaCallOption 在第 1 章的文件夹里，主要实现了 1 个简单的看涨期权（call option）的定价模型，由 3 部分组成。主程序是 SimpleMCMain1.cpp ，其中需要用到生成随机数的功能，所以引入了 1 个头文件（只有函数声明）的 Random1.h ，以及具体实现该功能的头文件 Random1_Implementation.h 1。&#xA;ch2-Encapsulation 在第 2 章，对于常用的功能进行了封装。这章用到的文件具体如下（表格内省略了用于实现接口的文件，例如 “Random1_Implementation.h”，后文的表格皆是如此）：&#xA;文件名称 用途 Random1.h 生成随机数的函数 PayOff1.h 以 Strike 与 TheOptionsType 为私有变量的 PayOff 类，主要特点由：1. 以 enum OptionType {call, put} 区分不同类型期权的定价方式（这里是 2 种：看涨期权、看跌期权）；2. 通过double operator() (double Spot) const 重载运算符 () ，以计算给定期权的 PayOff SimpleMC.h 用于最终定价的 Monte-Carlo 函数 SimpleMCMain2.</description>
    </item>
    <item>
      <title>基于测度论的概率论基础</title>
      <link>https://young-mann.top/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 14 Jul 2022 17:45:55 +0800</pubDate>
      <guid>https://young-mann.top/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/</guid>
      <description>本文介绍了概率空间$ ( \Omega, \mathcal{F}, {P} )$ 中 $\Omega, \mathcal F, P$ ，尤其是 $\mathcal F$ 的含义——事件域 $\mathcal F$ 包含了一系列划分后的集合，which 可以被我们用来对样本空间 $\Omega$ 中的样本路径 $\omega$ 进行归类。这些分类，实际上表示我们对于当前样本路径的了解程度：我们在某一阶段 $T$ 所知道的信息越多，这一阶段的事件域 $\mathcal F _T$ 所包含的元素就越多，表示我们对于 $\omega$ 所能选取的划分也就越多。&#xA;1. 描述样本空间 $\Omega$ 及其子集 假设我们现在关心的是「连续投掷2次硬币」这一随机试验。将硬币的某一面记作正面，与其相反的一面记作反面。将「硬币投出了正面」记作 H （假设其可能性为 $p,p&amp;gt;0$），将「硬币投出了反面」记作 T （假设其可能性为 $q, q=1-p&amp;gt;0$）。这一随机试验中，以序列$w_1w_2$（其中$w_i的可能取值为H或T$）列出所有可能的结果。此时的样本空间 $\Omega$ 为： $$ \Omega = \lbrace \text{HH, HT, TH, TT}\rbrace. \ $$&#xA;样本空间 Ω 列出了随机试验所有可能发生的结果。在这些过程中，有一些结果可能是我们所关心的。我们可以根据所关心的 内容，对 Ω 中的元素进行划分1，并将划分中的元素称作事件。例如，我们可能想了解 第1次掷币的结果是否是正面 。此时，我们可对样本空间 $\Omega$ 进行如下的划分： $$ C_1=\lbrace第1次掷币的结果是正面\rbrace =\lbrace \text{HH, HT}\rbrace, \ C_2=\lbrace第1次掷币的结果是反面\rbrace =\lbrace\text{TH, TT}\rbrace .</description>
    </item>
    <item>
      <title>为啥还有人直接用 LSTM 预测股价嘞？</title>
      <link>https://young-mann.top/posts/lstm/</link>
      <pubDate>Sun, 05 Jun 2022 02:34:12 +0800</pubDate>
      <guid>https://young-mann.top/posts/lstm/</guid>
      <description>最近提交了论文的最终稿，闲来无事和其他同学交流了一下，发现有俩同学在用 LSTM 预测股价。简单扫了一遍他们的文章，发现他在数据的处理上比较粗糙，没有太大实用价值。支撑我作出这个判断的，是他们没做到以下几件事：&#xA;在数据处理上，股价数据属于时序数据，需要先做平稳性检验，对输入数据做对数差分，保证预测变量和特征变量都是平稳的。&#xA;在模型选择上，由于金融时序数据的信噪比比较低，所以模型的参数不能太多，以免过拟合。&#xA;在预测目标上，选择了股价的绝对值（而非收益率），而股价这玩意是不稳定序列，任何扰动都是永续的，因此方差随时间会趋向无穷大。同时，从实际应用的角度上看，我们其实更希望得到的是下一期的股价和这一期相比，是涨了还是跌了，而不是预测股票价格的绝对值。&#xA;如果中了以上几条，相当于训练模型前啥准备工作都没做。这会导致什么结果呢？根据笔者以前的试验，LSTM 大概率只能学到一堆噪声（$y_t^{&amp;rsquo;}=y_{t-1}+\epsilon^{&amp;rsquo;}$），甚至直接把前一期的收盘价作为当期的预测值输出——在这种情况下，假设单日内股价涨跌幅限制 10%（比如 A 股市场），那么在使用 MSE 的情况下，预测的误差也一定不会超过 10%。虽然预测误差看起来不大，但实际上模型没学到啥有用的东西，没法用于在股市里的获利。&#xA;举个例子，某只股票今天的价格是10元，用模型预测其明天的价格是10.25元，结果真的到了第二天，发现股票价格跌到了 9.75 元。这时候，你计算绝对股价的误差，可能会发现，$(10.25-9.75)/9.75 = 5.13%$，好像预测差距并不大，但问题就是，股票每天的波动本来就不大。如果你真拿这个模型去股市里实战，你可能会发现，这个模型虽然可以做到每天预测股价的绝对值的误差都都很小，但是每天的涨跌其实都是乱猜的，怕不是没多久就赔麻了。</description>
    </item>
    <item>
      <title>侃侃「直言」</title>
      <link>https://young-mann.top/posts/%E7%9B%B4%E8%A8%80/</link>
      <pubDate>Fri, 01 Apr 2022 22:04:47 +0000</pubDate>
      <guid>https://young-mann.top/posts/%E7%9B%B4%E8%A8%80/</guid>
      <description>今天读了福柯文选《自我技术》中的2篇文章，即《何谓直言？》与《说真话的勇气》。前一篇结合了诸多对于古希腊文献的分析，对于“直言”这一概念的词源、定义及特征进行解释。后一篇文章则延续了前一篇文章对于“直言”的讨论，简要阐明了指明了“直言”在“自我实践”的发展历程中极为重要。这种重要性体现在“直言”能够作为一种特定的标准判断“他者”，而这种“他者”在“述说自己之真”的自我实践是必不可少的。&#xA;说实话，这两篇文章里，比较吸引我的，一是福柯对于自己所用的方法论（即“问题化置疑”）的阐述，二是福柯提出的“直言”这一概念。在此，笔者尝试对于文本中的观点及论证进行选择性的转述，权当是今天的写作练习（？）了。由于笔者的福柯文本并没有多少阅读量，对于书中使用的诸多概念或许都存在理解偏差。因此，还请谨慎对待文中所提到的福柯的观点。&#xA;福柯的“问题化置疑” “问题化置疑”是什么？简而言之，就是研究 如今被视作问题的事物 是 为何 且 如何 在当今成为（或者说被视作）问题的。在《何谓直言？》一文里，福柯将自己视作一名“思想史”学者（而非“观念史学者”），澄清了“观念史”与“思想史”在研究方法论上的差异：前者关注某个特定的概念是何时出现的，如何产生、发展的，又和其他相关的概念如何相互影响；而思想史的学者则不然——他们关注的，是某个 未曾被问题化的 经验领域或实践类型（这些经验和实践在过去是被人们理所当然、习以为常的、寂寂无名的），如何成为一个亟需解决的问题，从而引发了一系列探讨和争论，煽动了新的反对与抗争，并为过去的那一系列行为、习惯、实践、制度带来危机。研究某些事物是为何且如何成为问题，关注这类曾经不成问题的事物“问题化”的过程，便是福柯的研究切入点。&#xA;在福柯看来，这种研究方法论既不像他人批评的那样，属于历史唯心主义，也不是完全脱离了具体历史背景的空想。他认为，“问题化置疑”并不是再现一个历史上早已存在的对象，也不是通过术语创造一个完全不存在的对象，而是通过一套话语或非话语实践，践让某物进入真实-虚假的游戏中，将它构建为思考的对象。这种问题化不是某一种泛泛宏观的过程、不是随着历史阶段不断推演而自然而然地产生的。这些问题的起源本身就和关心这些问题的微观主体息息相关。基于某种预设的、确定的宏观条件，所能得到的问题化命题很有可能出现不同；反过来说，面对某一个特定的问题化命题，我们也只能说，这是由某个特定主体所提出的、与这个主体的具体经历、身处环境、先验知识息息相关的产物。不同的个体，能够产出不一样的问题化命题。某个事物问题化的标志是，身处当时历史情景下的某些特定主体对于这些问题进行了应答。&#xA;作为“他者甄选标准”的“直言” 人们使用何种话语、何种实践，来尝试言说关于主体的真理？&#xA;对于这个问题，福柯做出了一个假设：主体想要获取主体的真理时，是通过一种 允许“可能且能够谈论自身” 的话语形式，而非通过 被告知 的话语形式，实现这种真理的获取。当主体言说真相时，主体就呈现出了其自身。换而言之，通过这种 被声称而且也被认为是真实的话语的特有结构类型 所隐含的诸多条件和形式，主体认为自己言说了真相，也被他人承认为言说了真相；不仅自己将自己建构为、而且也被他人建构为话语真理的一个主体：他向自己展示、也像他人展示自己是讲真话的人。基于这个假设，福柯进行了一些历史的分析，回顾历史上“述说自我之真”的实践，将这些实践置于“关心自己，应用于自身”（epimeleia heautou）的思想背景与框架下加以考察。这种“关心自己”的原则促进了“自我教化”这一现象的发展，随之而来的，是一整套的自我实践被构想、实现和传播。此间，福柯提及了希腊和罗马文化中对于“述说自我之真”的鼓励。例如，毕达哥拉斯学派及斯多葛学派主张频繁、持久、连续的内心审视的实践；交流“道德”、“精神”话题的往来书信也很常见；更有意思的是，人们被建议保存他们自己的日记，或是作为对所经历或思考的内容的回顾，留待日后的引用，或是作为梦醒之后对于梦境的记录。&#xA;在“述说自己之真”这一实践中，“他者”的存在是必不可少的。在基督教出现很久以前，“述说自己之真”这一实践是涉及几个人的活动，是和他人一起的活动，或者是，是与另一个人的活动。在基督教时代以及现代，我们都熟悉有这样的一个他者。可是，再在此之前，这样的“他者”形象就更加模糊、不明确、捉摸不透了——他可以是一位年长的老师，也许是一个私人的朋友，也可能是任意一个人。这种他者是多面向的，或许是政治的、医学的或是教育的。这种他者，并不像基督教文化中的忏悔师，或是先待的心理分析师那样，需要从机制性的代表那里获取资格。相应的，他们所需要的资格，是一种实践，是某种言说的方式，也就是“直言”（parrhēsia）。&#xA;直言（parrhēsia）的意思是“说出一切”。直言者（parrhēsiastēs）是说出心中所想之一切的言说者，即使他所说的东西可能会危及其生命——例如，在他的言论与国王或绝大多数民众所相信的东西不相符合的情况下。“直言”意味着告知一切，且告知的内容与真理相联系。直言者深信自己所说的东西为真，而且他们所说的东西实际上也确实为真。此外，“直言”是需要冒风险的。因为，要想言说真理，就应当越出对话者所持有的所谓“共同价值观”。这种“越出”将成为直言之批判维度的根基所在。一旦“直言”，就必须造成和直面冒犯他人、使他人烦躁、激怒他人、刺激他人，乃至诉诸极端暴力行为的危险——这是一种挑战，是地位相对低者对地位相对高者的挑战，是冒着打破和结束和他者的关系的危险 所进行的一种实践。最后，“直言”还与直言者的道德责任感息息相关——直言者本可以享有“保持沉默的自由。没有人强迫他说话，但他觉得自己有这样做的责任……因此，直言与自由和责任息息相关”。为了在直言的意义上说真话，一个人必须有通过说谎或缄口不言而不说真话的自由。要想说出真理，说真话者需要与自身建立起某种伦理关系。直言者“冒着死亡的危险去说出真理，而非停留于真理未曾言明的安全地带……他宁肯做一个说真话者，而不是过一种自欺欺人的生活”。在道德层面上，说真话是值得钦佩的，因为相较于不说真话，说真话要更加举步维艰。&#xA;除了上述内容以外，福柯还讨论了“直言”的积极用法与消极用法、“直言”和修辞之间的关系，以及“直言”和其他3种说真话方式的不同。不过，笔者对于这些部分的内容并无太多兴趣，因此不打算再做转述。</description>
    </item>
    <item>
      <title>关系数据理论</title>
      <link>https://young-mann.top/posts/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</link>
      <pubDate>Tue, 18 May 2021 19:31:10 +0800</pubDate>
      <guid>https://young-mann.top/posts/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</guid>
      <description>本文是《数据库系统概论》的第6章以及“Database System: The Complete Book”的第三章所作的部分笔记，用以理解数据库设计过程中的关系数据理论。笔者认为，在这些教材中，对于关系数据理论的阐释可被归结为对于以下几个问题的回应：&#xA;一个糟糕的数据库设计是什么样的，又会为使用者带来多少麻烦？（问题的引入） 是否存在某些可以遵循的准则，帮助我们设计出“不那么糟糕”的数据库？（规范化理论） 在了解“不那么糟糕的数据库应该是什么样的”之后，我们又能采取哪些措施，让我们在设计数据库时满足这些让数据库运作得更好的条件？（Armstrong公理&amp;amp;模式分解） 预备知识 为了更好地理解下文的内容，读者首先需要掌握关系数据理论中的部分基本概念：&#xA;函数依赖(Functional Dependency) 函数依赖：设 R(U) 是属性集U的关系模型, X, Y是U的一个子集, 对于 R(U) 中的任一个关系 r, 不可能存在两个元组在 X 上属性值相同, 而在 Y 上属性值不同。则称 X 函数确定 Y , 或 Y 函数依赖 X ，记作$X \rightarrow Y$。 完全函数依赖：如果Y函数依赖X，但不依赖X的任何一个真子集，则称Y完全函数依赖X，记作$X \xrightarrow F Y$。 部分函数依赖：如果Y函数依赖X，但依赖于X的任何一个真子集，则称Y部分函数依赖X，记作$X \xrightarrow P Y$。 传递函数依赖：设Z也是U的一个子集。如果X决定Y，Y决定Z，且Y不决定X，那么称Z对X传递函数依赖，记作$X \xrightarrow {传递} Y$。 码/键(Key) 候选码：设属性集U包含关系模式内所有可能的属性值，K是U的子集，若$K\xrightarrow F U$，则称K为候选码（K是一个集合！）&#xA;主码：候选码若有多个，则选定其中的一个，称为主码。&#xA;超码：对于属性集U，候选码K，若$K\xrightarrow P U$，则称K为超码。&#xA;主属性/非主属性：包含在任何一个候选码的属性都叫主属性，其他都叫非主属性。&#xA;范式（Normal Form） 对于范式的概念，特别不靠谱的理解如下：&#xA;第一范式(1NF)：不能出现类似excel中合并单元格的那种情形？（要求一个关系中的所有字段值都是不可分解的原子值）&#xA;第二范式(2NF)：在满足1NF的基础上，还需要满足：在其他非主属性与主键的函数依赖关系中，主键集合中是作为一个整体起到函数决定的作用的。反过来说，就是不能出现这样一种情况：主键中的某个主属性仅凭自身便能决定其它的非主属性，而函数决定其它的非主属性主键只有作为包含了（不存在非主属性对主键的部分函数依赖关系）。&#xA;第三范式(3NF)：在满足2NF的基础上，对于一个关系内的非主属性，他们能且仅能被主键唯一地表示。换而言之，该关系模式内存在的函数依赖关系都是由主键所决定的。除了这些被主键决定的函数依赖关系之外，非主属性之间必须相互独立，再也不能出现其他的函数依赖关系。&#xA;BCNF: 在满足3NF的基础上，将“对于一个关系内的非主属性，他们能且仅能被主键唯一地表示”成了“对于一个关系内的所有属性，他们能且仅能被主键唯一地表示”，所需要满足的条件比3NF更加严格。&#xA;第四范式(4NF)：原关系模式中不存在非平凡的多值依赖。&#xA;问题的引入——数据异常及规范化理论 当我们在设计数据库时，若我们考虑不当，将过多的要素全部塞进了一张单独的表时，那么后续操作这张表时可能会引发诸多意料之外的异常情况(anomality)，如：</description>
    </item>
    <item>
      <title>浮点数的取值范围</title>
      <link>https://young-mann.top/posts/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Tue, 23 Feb 2021 22:58:40 +0800</pubDate>
      <guid>https://young-mann.top/posts/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</guid>
      <description>本文以单精度浮点格式（即C++中的float类型）为例，简要介绍 IEEE754 标准中浮点数的表示方法，以及该表示方法中需要特别注意的部分（即浮点数中的阶码是以移码形式存储的），并基于上述两点，求得单精度浮点数的有效数字的位数以及取值范围。其他类型浮点格式的有效数字位数及取值范围可依此类推。&#xA;前置知识 若想了解浮点数在计算机内被如何存储，就必须先了解 IEEE754 标准，which 制定了计算机内浮点数及其运算的标准，被目前几乎所有的计算机所支持。&#xA;IEEE754 标准 根据IEEE浮点数标准，一个浮点数可表达为： $$ V=(-1)^s \times M \times 2^E $$&#xA;其中，&#xA;V 表示所表示的浮点数的实际值 s 为符号位(Sign)，表示该浮点数为正数或负数。若为正数，则 s 取值为0；若为负数，则 s 取值为1 (注：对于数值0的符号位需要特殊处理) M 为尾数(Mantissa)，是一个二进制小数，用于确定浮点数的精度，以定点数的形式存储在计算机内部（注意：此处的尾数的形式实为1.ffffff，而非0.fffffff，这个特征在下文讨论移码时会被重新提及） E 为阶码(Exponent)，用于对浮点数进行加权 (!!!注意!!!：阶码的取值可正可负，是一个有符号数，分别代表小数点是向左移还是向右移。出于使用上的便利，在存储阶码时用到了特别的方式，即下文即将提到的移码(Excess-N System) ） 将浮点数的位表示划分为三个字段，并分别对这些值进行编码，便可表示出浮点数的实际值。以单精度浮点格式为例。在单精度浮点格式中，符号位s、阶码E和尾数M的尾数分别为1位、8位和23位，将三者联立便可得到以32位表示出的浮点数，具体形式可参见下图：&#xA;图源：Foundations of Computer Science (2018), Behrouz Forouzan&#xA;阶码的存储形式——移码 (Excess-N System) 为啥不能用补码存储阶码？ 在上文中我们提到，阶码 E 是一个有符号数，用于表示小数点需要向左或向右移动的位数。那么，在存储阶码时，根据此前所学的知识，我们自然会想到以补码 (2&amp;rsquo;s complement) 的形式存储阶码。&#xA;但是，我们在课本上看到的阶码可不是用补码表示的。这是为什么呢？说实话，我不太确定真正的原因，现在能想到的理由如下：以补码表示的阶码会出现一个新的符号位（区别于上文 IEEE754 标准中所提到的符号位s），使得一个浮点数中出现两个符号位：浮点数本身的，以及浮点数阶码前的。这时，如果要对浮点数进行运算或者比较，无法采用整数那样的简单的二进制比较，所以算起来并不方便。&#xA;那有啥更好的方法存储阶码？ 既然不能用补码，那我们只能另辟蹊径了。回顾用补码表示阶码所产生的问题，可以发现，阶码作为有符号数时具备的符号位是引发麻烦的源头，那么为了方便起见，只能想着除去符号位了。基于这种思想，前人提出了移码(Excess-N System)的存储方式。简单而言，补码在存储阶码时所起到的作用，便是对于 作为有符号数的阶码 的所有可能取值，分别增加一个特定的值N（即$2^{m_E-1}-1$，也是上文中Excess-N中N的含义），从而将原本所有可能的取值映射到一个新的正数集合。基于该正数集合，我们可以找出与原阶码一一对应的无符号数。通过移码，我们不再需要考虑如何处理原本作为有符号数的阶码所包含的符号位（因为阶码的所有可能取值已经被我们映射到了一个正整数集合）。因此，当我们需要对阶码进行运算或比较时，便可以将这些运算或比较先作用于新的整数集合上，再通过映射的逆操作得到我们所需的阶码值。&#xA;等等……上面那个用于增加的值 $2^{m_E-1}-1$ 是啥玩意儿？ 至此，移码在阶码存储中的用途便讲得差不多了……不过，我是不是忘了什么？哦，在读上面那段的时候，你可能在想，那个$2^{m_E-1}-1$是啥？简单来说，这是将有符号数的阶码全部映射成正整数的一个比较合适的取值，其中$m_E$ 表示的是存储阶码可用的存储单元的位数，在单精度浮点格式里是8位。&#xA;还是以单精度浮点格式为例。上文中，我们提到，作为有符号数的阶码有正有负，在单精度浮点格式里的取值范围是 -126~127 （为啥不是 -128~127 ?</description>
    </item>
  </channel>
</rss>
